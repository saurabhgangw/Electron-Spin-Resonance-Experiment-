# -*- coding: utf-8 -*-
"""Untitled82.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kgNRPBuPvO17zxDJq9xwUhGdAqvkyF9F
"""

# Basic Imports and Documentation
import numpy as np  # NumPy Array Programming: https://numpy.org/doc/stable/reference/arrays.html
import matplotlib.pyplot as plt  # Matplotlib Plotting: https://matplotlib.org/stable/api/pyplot_api.html
from numba import jit, prange  # Numba JIT Compilation: https://numba.readthedocs.io/en/stable/user/jit.html
import time  # Python Time Functions: https://docs.python.org/3/library/time.html
#code with all ref for sphere
# Configuration Parameters
# Reference: Jamming of Soft Spheres - https://journals.aps.org/pre/abstract/10.1103/PhysRevE.68.011306
num_spheres = 100  # System size studies: https://doi.org/10.1103/PhysRevE.74.061308
radius = 1.0  # Unit radius convention: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.70.043301
densities = [0.30, 0.38, 0.45, 0.52, 0.59, 0.63, 0.64, 0.69, 0.72]  # Density range: https://doi.org/10.1103/PhysRevLett.88.075507
num_configurations = 5  # Statistical sampling: https://doi.org/10.1103/PhysRevE.80.021302
density_threshold = 0.65  # Jamming transition: https://doi.org/10.1103/PhysRevLett.95.098301

@jit(nopython=True, fastmath=True, parallel=True)
# Numba Optimization: https://numba.readthedocs.io/en/stable/user/performance-tips.html
def compute_energy_and_gradient(spheres, box_size, density):
    """
    Energy and gradient computation
    Reference: Molecular Dynamics Methods - https://doi.org/10.1063/1.445869
    Periodic Boundaries: https://doi.org/10.1016/j.cpc.2008.01.006
    """
    n = len(spheres) // 3  # Coordinate system: https://doi.org/10.1016/j.cpc.2008.01.006
    spheres = spheres.reshape(n, 3)  # Array operations: https://numpy.org/doc/stable/reference/generated/numpy.reshape.html

    gradient = np.zeros((n, 3))  # Force calculation: https://doi.org/10.1063/1.4812323
    energy = 0.0  # Energy initialization: https://doi.org/10.1063/1.445869

    # Particle interactions: https://doi.org/10.1103/PhysRevE.68.011306
    for i in prange(n):  # Parallel computation: https://numba.readthedocs.io/en/stable/user/parallel.html
        for j in range(i + 1, n):
            rij = spheres[i] - spheres[j]  # Distance vector: https://doi.org/10.1016/j.cpc.2008.01.006
            rij = rij - box_size * np.round(rij / box_size)  # PBC: https://doi.org/10.1016/j.cpc.2008.01.006
            dist2 = np.sum(rij * rij)

            # Soft sphere potential: https://doi.org/10.1103/PhysRevE.68.011306
            if dist2 < (2 * radius) ** 2:
                dist = np.sqrt(dist2)
                overlap = 2 * radius - dist
                if overlap > 0:
                    # Energy calculation: https://doi.org/10.1103/PhysRevLett.88.075507
                    if density < density_threshold:
                        energy += 0
                    else:
                        energy += overlap**2

                    # Force calculation: https://doi.org/10.1063/1.445869
                    grad_mag = 2 * overlap / dist
                    gradient[i] += grad_mag * rij
                    gradient[j] -= grad_mag * rij

    return energy, gradient.flatten()

@jit(nopython=True)
# Optimization methods: https://doi.org/10.1137/S1052623497318992
def line_search(spheres, direction, grad, box_size, density, alpha_init=1.0, c1=1e-6, tau=0.7):
    """
    Line search implementation
    Reference: Numerical Optimization - https://doi.org/10.1007/978-0-387-40065-5_3
    """
    alpha = alpha_init
    f0, _ = compute_energy_and_gradient(spheres, box_size, density)
    descent = np.dot(grad, direction)  # Descent direction: https://doi.org/10.1137/S1052623497318992

    # Backtracking: https://doi.org/10.1007/978-0-387-40065-5_3
    for _ in range(10):
        new_spheres = spheres + alpha * direction
        f_new, _ = compute_energy_and_gradient(new_spheres, box_size, density)
        if f_new <= f0 + c1 * alpha * descent:
            break
        alpha *= tau

    return alpha

@jit(nopython=True)
# Conjugate gradient method: http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf
def nonlinear_conjugate_gradient(spheres, box_size, density, max_iter=50, tol=1e-6):
    """
    Nonlinear CG optimization
    Reference: Painless Conjugate Gradient - http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf
    """
    spheres = spheres.flatten()
    _, grad = compute_energy_and_gradient(spheres, box_size, density)
    direction = -grad
    rsold = np.dot(grad, grad)

    # Iterative optimization: https://doi.org/10.1137/S1052623497318992
    for _ in range(max_iter):
        alpha = line_search(spheres, direction, grad, box_size, density)
        new_spheres = spheres + alpha * direction
        new_spheres = new_spheres.reshape(-1, 3) % box_size
        new_spheres = new_spheres.flatten()

        _, new_grad = compute_energy_and_gradient(new_spheres, box_size, density)
        rsnew = np.dot(new_grad, new_grad)

        if rsnew < tol**2:  # Convergence check: https://doi.org/10.1137/S1052623403428793
            break

        beta = max(0, np.dot(new_grad, new_grad - grad) / rsold)
        direction = -new_grad + beta * direction
        grad = new_grad
        rsold = rsnew
        spheres = new_spheres

    return spheres.reshape(-1, 3)

# System initialization: https://doi.org/10.1103/PhysRevE.70.043301
def initialize_spheres_random(box_size, num_spheres):
    """
    Random initialization
    Reference: Monte Carlo Methods - https://doi.org/10.1063/1.1699114
    """
    return np.random.uniform(0, box_size, (num_spheres, 3))

# Main optimization routine: https://doi.org/10.1103/PhysRevLett.88.075507
def optimize_spheres():
    """
    Main optimization function
    Reference: Energy Minimization - https://doi.org/10.1103/PhysRevE.70.043301
    """
    # Plotting setup: https://matplotlib.org/stable/api/figure_api.html
    plt.figure(figsize=(10, 6))
    energy_per_density = {density: [] for density in densities}

    # Density loop: https://doi.org/10.1103/PhysRevE.68.011306
    for density in densities:
        volume_per_sphere = (4 / 3) * np.pi * radius**3
        total_volume = num_spheres * volume_per_sphere
        box_size = (total_volume / density) ** (1 / 3)

        # Configuration sampling: https://doi.org/10.1103/PhysRevE.80.021302
        for config in range(num_configurations):
            spheres = initialize_spheres_random(box_size, num_spheres)
            final_spheres = nonlinear_conjugate_gradient(spheres.copy(), box_size, density)
            final_energy, _ = compute_energy_and_gradient(final_spheres.flatten(), box_size, density)
            energy_per_density[density].append(final_energy)

    # Data analysis: https://doi.org/10.1103/PhysRevE.80.021302
    densities_list = sorted(densities)
    avg_energies = [np.mean(energy_per_density[d]) for d in densities_list]
    std_energies = [np.std(energy_per_density[d]) for d in densities_list]

    # Plotting: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.errorbar.html
    plt.errorbar(densities_list, avg_energies, yerr=std_energies, fmt='o-', capsize=5, label="Spheres")
    plt.xlabel('Density')
    plt.ylabel('Average Energy')
    plt.title('Average Energy vs Density for Spheres')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    optimize_spheres()