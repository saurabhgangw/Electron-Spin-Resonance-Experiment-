# -*- coding: utf-8 -*-
"""Untitled82.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kgNRPBuPvO17zxDJq9xwUhGdAqvkyF9F
"""



# Basic Imports and Documentation
import numpy as np  # NumPy Array Programming: https://numpy.org/doc/stable/reference/arrays.html
import matplotlib.pyplot as plt  # Matplotlib Plotting: https://matplotlib.org/stable/api/pyplot_api.html
from numba import jit, prange  # Numba JIT Compilation: https://numba.readthedocs.io/en/stable/user/jit.html
import time  # Python Time Functions: https://docs.python.org/3/library/time.html

# Configuration Parameters
# Reference: Dumbbell Molecular Dynamics - https://doi.org/10.1063/1.4812323
num_dumbbells = 50  # System size (each dumbbell = 2 spheres): https://doi.org/10.1103/PhysRevE.74.061308
radius = 1.0  # Sphere radius in dumbbell: https://doi.org/10.1103/PhysRevE.70.043301
L_ratios = [1.0, 1.5, 2.0, 2.5]  # Separation to radius ratios: https://doi.org/10.1103/PhysRevE.68.011306
densities = [0.30, 0.38, 0.45, 0.52, 0.59, 0.63, 0.64, 0.69, 0.72]  # Density range
num_configurations = 5  # Statistical sampling: https://doi.org/10.1103/PhysRevE.80.021302

@jit(nopython=True, fastmath=True, parallel=True)
# Numba Optimization: https://numba.readthedocs.io/en/stable/user/performance-tips.html
def compute_dumbbell_energy_and_gradient(dumbbells, box_size, density, L):
    """
    Compute energy and gradient for dumbbell system.
    Reference: Molecular Dynamics Methods - https://doi.org/10.1063/1.445869
    Dumbbell Interactions: https://doi.org/10.1103/PhysRevE.74.061308
    """
    n = len(dumbbells) // 6  # Each dumbbell has 2 spheres (6 coordinates)
    dumbbells = dumbbells.reshape(n, 2, 3)  # Reshape to (n, 2, 3) for dumbbells

    gradient = np.zeros((2 * n, 3))  # Force calculation: https://doi.org/10.1063/1.4812323
    energy = 0.0  # Energy initialization: https://doi.org/10.1063/1.445869

    # Dumbbell interactions: https://doi.org/10.1103/PhysRevE.68.011306
    for i in prange(n):
        for j in range(i + 1, n):
            for k1 in range(2):  # First sphere of dumbbell i
                for k2 in range(2):  # First sphere of dumbbell j
                    rij = dumbbells[i, k1] - dumbbells[j, k2]
                    rij = rij - box_size * np.round(rij / box_size)  # PBC
                    dist2 = np.sum(rij * rij)

                    if dist2 < (2 * radius) ** 2:
                        dist = np.sqrt(dist2)
                        overlap = 2 * radius - dist
                        if overlap > 0:
                            energy += overlap**2  # Energy penalty for overlaps
                            grad_mag = 2 * overlap / dist
                            gradient[i * 2 + k1] += grad_mag * rij
                            gradient[j * 2 + k2] -= grad_mag * rij

        # Enforce dumbbell constraint: fixed distance L between spheres
        # Reference: Rigid Body Constraints - https://doi.org/10.1016/j.jcp.2015.07.004
        r12 = dumbbells[i, 0] - dumbbells[i, 1]
        r12 = r12 - box_size * np.round(r12 / box_size)  # PBC for constraint
        dist2 = np.sum(r12 * r12)
        dist = np.sqrt(dist2)
        constraint_violation = dist - L
        grad_mag = 2 * constraint_violation / dist
        gradient[i * 2] += grad_mag * r12
        gradient[i * 2 + 1] -= grad_mag * r12
        energy += 100.0 * constraint_violation**2  # Strong constraint penalty

    return energy, gradient.flatten()

@jit(nopython=True)
# Optimization methods: https://doi.org/10.1137/S1052623497318992
def line_search_dumbbell(dumbbells, direction, grad, box_size, density, L, alpha_init=1.0, c1=1e-6, tau=0.7):
    """
    Line search implementation for dumbbells
    Reference: Numerical Optimization - https://doi.org/10.1007/978-0-387-40065-5_3
    """
    alpha = alpha_init
    f0, _ = compute_dumbbell_energy_and_gradient(dumbbells, box_size, density, L)
    descent = np.dot(grad, direction)

    for _ in range(10):
        new_dumbbells = dumbbells + alpha * direction
        f_new, _ = compute_dumbbell_energy_and_gradient(new_dumbbells, box_size, density, L)
        if f_new <= f0 + c1 * alpha * descent:
            break
        alpha *= tau

    return alpha

@jit(nopython=True)
# Conjugate gradient method: http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf
def nonlinear_conjugate_gradient_dumbbell(dumbbells, box_size, density, L, max_iter=50, tol=1e-6):
    """
    Nonlinear CG optimization for dumbbells
    Reference: Painless Conjugate Gradient - http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf
    """
    dumbbells = dumbbells.flatten()
    _, grad = compute_dumbbell_energy_and_gradient(dumbbells, box_size, density, L)
    direction = -grad
    rsold = np.dot(grad, grad)

    for _ in range(max_iter):
        alpha = line_search_dumbbell(dumbbells, direction, grad, box_size, density, L)
        new_dumbbells = dumbbells + alpha * direction
        new_dumbbells = new_dumbbells.reshape(-1, 2, 3) % box_size
        new_dumbbells = new_dumbbells.flatten()

        _, new_grad = compute_dumbbell_energy_and_gradient(new_dumbbells, box_size, density, L)
        rsnew = np.dot(new_grad, new_grad)

        if rsnew < tol**2:
            break

        beta = max(0, np.dot(new_grad, new_grad - grad) / rsold)
        direction = -new_grad + beta * direction
        grad = new_grad
        rsold = rsnew
        dumbbells = new_dumbbells

    return dumbbells.reshape(-1, 2, 3)

def initialize_dumbbells_random(box_size, num_dumbbells, L):
    """
    Initialize random positions for dumbbells
    Reference: Monte Carlo Methods - https://doi.org/10.1063/1.1699114
    """
    dumbbells = []
    for _ in range(num_dumbbells):
        center = np.random.uniform(0, box_size, 3)
        direction = np.random.uniform(-1, 1, 3)
        direction /= np.linalg.norm(direction)
        offset = (L / 2) * direction
        dumbbells.append([center - offset, center + offset])
    return np.array(dumbbells)

def optimize_dumbbells():
    """
    Optimize dumbbell configurations for various L/R ratios
    Reference: Jamming Transition - https://doi.org/10.1103/PhysRevLett.88.075507
    """
    plt.figure(figsize=(10, 6))

    for L_ratio in L_ratios:
        print(f"\nProcessing L/R ratio: {L_ratio}")
        L = L_ratio * radius
        energy_per_density = {density: [] for density in densities}

        for density in densities:
            print(f"  Processing density: {density}")
            volume_per_dumbbell = 2 * (4/3) * np.pi * radius**3
            total_volume = num_dumbbells * volume_per_dumbbell
            box_size = (total_volume / density) ** (1/3)

            for config in range(num_configurations):
                dumbbells = initialize_dumbbells_random(box_size, num_dumbbells, L)
                final_dumbbells = nonlinear_conjugate_gradient_dumbbell(dumbbells.copy(), box_size, density, L)
                final_energy, _ = compute_dumbbell_energy_and_gradient(final_dumbbells.flatten(), box_size, density, L)
                energy_per_density[density].append(final_energy)

        densities_list = sorted(densities)
        avg_energies = [np.mean(energy_per_density[d]) for d in densities_list]
        std_energies = [np.std(energy_per_density[d]) for d in densities_list]

        plt.errorbar(densities_list, avg_energies, yerr=std_energies, fmt='o-', capsize=5, label=f"L/R = {L_ratio:.1f}")

    plt.xlabel('Density')
    plt.ylabel('Average Energy')
    plt.title('Average Energy vs Density for Different L/R Ratios')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    optimize_dumbbells()